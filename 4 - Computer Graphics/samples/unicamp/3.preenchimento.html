<html><head><title>Preenchimento de regiões</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta content="MSHTML 6.00.2722.900" name="GENERATOR"><link title="Introdução à computação gráfica com OpenGL" href="http://www.ceset.unicamp.br/%7Emagic/opengl/index2005.html" rel="HOME"><link title="Exercícios" href="http://www.ceset.unicamp.br/%7Emagic/opengl/desenhando-exercicios.html" rel="PREVIOUS"><link title="Exercícios" href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento-outros.html" rel="NEXT"></head><body text="#000000" bgcolor="#ffffff">
<div class="NAVHEADER">
<table width="100%" border="0" cellpadding="0" cellspacing="0">
  <tbody>
  <tr>
    <th colspan="3" align="middle">Introdução à computação gráfica com 
OpenGL</th></tr>
  <tr>
    <td valign="bottom" width="10%" align="left"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/desenhando-exercicios.html">Prev</a></td>
    <td valign="bottom" width="80%" align="middle"></td>
    <td valign="bottom" width="10%" align="right"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento-outros.html">Next</a></td></tr></tbody></table>
<hr width="100%" align="left">
</div>
<div class="CHAPTER">
<h1><a name="PREENCHIMENTO">Capítulo 3. Preenchimento de regiões</a></h1>
<div class="TOC">
<dl>
  <dt><b>Índice</b>
  </dt><dt>3.1. <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento.html#AEN361">Descrição 
  do programa <tt class="FILENAME">preenchimento.c</tt></a>
  </dt><dt>3.2. <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento-outros.html">Programas relacionados</a></dt>
  <dt>3.3. <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento-exercicios.html">Exercícios</a></dt></dl></div>
<p>O propósito desta lição é aprender funções básicas do OpenGL que tratam do 
preenchimento de regiões. Será mostrado um programa de desenho de polígonos com 
preenchimento interno com cores sólidas, padrões e combinações de cores. O 
programa analisado, <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento.c" target="_top"><tt class="FILENAME">preenchimento.c</tt></a>, é mostrado no <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento.html#EXAMPLE-PREENCHIMENTO">Exemplo 
3-1</a>.</p>
<div class="EXAMPLE">
<p><b><a name="EXAMPLE-PREENCHIMENTO">Exemplo 3-1. programa </a><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento.c" target="_top"><tt class="FILENAME">preenchimento.c</tt></a></b></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

GLubyte tux[] = {
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x7f,  0xfe,  0x0, 
 0x0,  0xc4,  0x23,  0x0, 
 0x1,  0x83,  0x21,  0x80, 
 0x1,  0x7,  0xe0,  0x80, 
 0x1,  0x7,  0xf0,  0x80, 
 0x1,  0x8f,  0xf9,  0x80, 
 0x0,  0xff,  0xff,  0x0, 
 0x0,  0x4f,  0xf1,  0x0, 
 0x0,  0x6f,  0xf1,  0x0, 
 0x0,  0x2f,  0xf3,  0x0, 
 0x0,  0x27,  0xe2,  0x0, 
 0x0,  0x30,  0x66,  0x0, 
 0x0,  0x1b,  0x1c,  0x0, 
 0x0,  0xb,  0x88,  0x0, 
 0x0,  0xb,  0x98,  0x0, 
 0x0,  0x8,  0x18,  0x0, 
 0x0,  0xa,  0x90,  0x0, 
 0x0,  0x8,  0x10,  0x0, 
 0x0,  0xc,  0x30,  0x0, 
 0x0,  0x6,  0x60,  0x0, 
 0x0,  0x3,  0xc0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0
};

GLfloat r,g,b;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void mouse(int button, int state, int x, int y);

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (256, 256); 
  glutInitWindowPosition (100, 100); 
  glutCreateWindow ("Preenchendo regiões");
  init();
  glutDisplayFunc(display); 
  glutKeyboardFunc(keyboard);
  glutMouseFunc(mouse);
  glutMainLoop();
  return 0;
}

void init(void){
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glOrtho (0, 256, 0, 256, -1 ,1);
  r=0; g=1; b=0;
}

void display(void){
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glDisable(GL_POLYGON_STIPPLE);

  glPolygonMode(GL_BACK, GL_LINE);
  glColor3f(1.0, 0.0, 0.0);
  glBegin(GL_POLYGON);
  glVertex2i(30,226);  glVertex2i(113,226);
  glVertex2i(113,143); glVertex2i(30,143); 
  glEnd();

  glPolygonMode(GL_BACK, GL_FILL);
  glColor3f(r, g, b);
  glBegin(GL_POLYGON);
  glVertex2i(143,226); glVertex2i(226,226);
  glVertex2i(226,143); glVertex2i(143,143); 
  glEnd();

  glBegin(GL_POLYGON);
  glColor3f(1.0, 0.0, 0.0);  glVertex2i(30,113);  
  glColor3f(0.0, 1.0, 0.0);  glVertex2i(113,113);
  glColor3f(0.0, 0.0, 1.0);  glVertex2i(113,30);  
  glColor3f(1.0, 1.0, 0.0);  glVertex2i(30,30); 
  glEnd();

  glEnable(GL_POLYGON_STIPPLE);
  glColor3f(1.0, 0.0, 1.0);
  glPolygonStipple(tux);
  glBegin(GL_POLYGON);
  glVertex2i(143,113); glVertex2i(226,113);
  glVertex2i(226,30); glVertex2i(143,30); 
  glEnd();
  glFlush();
  glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
  case 27:
	exit(0);
	break;
  }
}

void mouse(int button, int state, int x, int y){
  switch (button) {
  case GLUT_LEFT_BUTTON:
	if (state == GLUT_DOWN) {
	  r=(GLfloat)rand()/(RAND_MAX+1.0);
	  g=(GLfloat)rand()/(RAND_MAX+1.0);
	  b=(GLfloat)rand()/(RAND_MAX+1.0);
	  glutPostRedisplay();
	}
	break;
  }
}</pre></td></tr></tbody></table></div>
<p>Para compilar e executar o programa <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento.c" target="_top"><tt class="FILENAME">preenchimento.c</tt></a>, salve-o juntamente com 
o arquivo <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/Makefile" target="_top">Makefile</a> em um diretório e execute a seguinte seqüência de 
comandos:</p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="SCREEN"><tt class="PROMPT">$</tt> <b class="COMMAND">make</b> <span class="OPTION">preenchimento</span>
<tt class="PROMPT">$</tt> <b class="COMMAND">preenchimento</b></pre></td></tr></tbody></table>
<p>A saída do programa <b class="COMMAND">preenchimento</b> é mostrado na <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento.html#FIG-PREENCHIMENTO">Figura 
3-1</a>.</p>
<div class="FIGURE">
<p><b><a name="FIG-PREENCHIMENTO">Figura 3-1. Saída do programa <b class="COMMAND">preenchimento</b>.</a></b></p><font color="red"><font color="red"><font color="red"></font></font></font>
<p><img src="3.preenchimento_arquivos/preenchimento.jpg"></p></div>
<div class="SECT1">
<h1 class="SECT1"><a name="AEN361">3.1. Descrição do programa <tt class="FILENAME">preenchimento.c</tt></a></h1>
<p>Serão descritas aqui apenas as partes do programa que acrescentam conceitos 
novos em relação aos exemplos anteriores.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">GLubyte tux[] = {
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x7f,  0xfe,  0x0, 
 0x0,  0xc4,  0x23,  0x0, 
 0x1,  0x83,  0x21,  0x80, 
 0x1,  0x7,  0xe0,  0x80, 
 0x1,  0x7,  0xf0,  0x80, 
 0x1,  0x8f,  0xf9,  0x80, 
 0x0,  0xff,  0xff,  0x0, 
 0x0,  0x4f,  0xf1,  0x0, 
 0x0,  0x6f,  0xf1,  0x0, 
 0x0,  0x2f,  0xf3,  0x0, 
 0x0,  0x27,  0xe2,  0x0, 
 0x0,  0x30,  0x66,  0x0, 
 0x0,  0x1b,  0x1c,  0x0, 
 0x0,  0xb,  0x88,  0x0, 
 0x0,  0xb,  0x98,  0x0, 
 0x0,  0x8,  0x18,  0x0, 
 0x0,  0xa,  0x90,  0x0, 
 0x0,  0x8,  0x10,  0x0, 
 0x0,  0xc,  0x30,  0x0, 
 0x0,  0x6,  0x60,  0x0, 
 0x0,  0x3,  0xc0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0, 
 0x0,  0x0,  0x0,  0x0
};</pre></td></tr></tbody></table>
<p></p></div>
<p>Define o vetor <font color="red">tux[]</font>, do tipo <span class="TYPE">GLubyte</span>, para representar o padrão de preenchimento de 
polígonos utilizado neste exemplo.</p>
<p>Existem dois métodos principais para preencher regiões utilizando padrões. O 
mais comum utiliza texturas, mas não será abordado nesta lição. O outro método 
consiste em definir um mapa de bits monocromático de 32x32 pixels, representando 
a máscara para o padrão que se deseja desenhar. O padrão utilizado neste exemplo 
é mostrado na <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento.html#FIG-TUXFIG">Figura 
3-2</a>.</p>
<div class="FIGURE">
<p><b><a name="FIG-TUXFIG">Figura 3-2. Padrão de desenho "tux".</a></b></p>
<p><img src="3.preenchimento_arquivos/tuxfig.jpg"></p></div>
<p>A máscara de desenho (vetor <font color="red">tux[]</font>) é formada por um 
conjunto de números representados na forma hexadecimal. Para construir este 
vetor, toma-se cada linha do mapa de bits de baixo para cima. Cada 8 pixels de 
uma linha da figura equivalem aos bits componentes de um elemento do vetor. Os 
bits mais significativos ficam à esquerda e os menos significativos à direita. 
Seguindo esta receita, então a linha 8 da <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento.html#FIG-TUXFIG">Figura 
3-2</a>, representada pela seqüência de bits <i class="EMPHASIS">00000000110001000010001100000000</i>, equivalerá à seqüência 
"0x0, 0xc4, 0x23, 0x0" do array <font color="red">tux[]</font>. </p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);</pre></td></tr></tbody></table>
<p></p></div>
<p>A função <tt class="FUNCTION">glutInitDisplayMode()</tt> avisa GLUT para 
utilizar dois <i class="FOREIGNPHRASE">buffers</i> no desenho de cenas: um 
principal e outro auxiliar. Todos os objetos deverão desenhados no buffer 
auxiliar. Quando a função <tt class="FUNCTION">glutSwapBuffers()</tt> for chamada, 
o buffer auxiliar passa a ser o principal, e o principal toma o lugar do 
auxiliar. Assim, a imagem gerada é apresentada de uma só vez na tela, evitando 
cintilações e a visualização do processo de desenho, efeitos indesejáveis 
principalmente em animações. </p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glutMouseFunc(mouse);</pre></td></tr></tbody></table>
<p></p></div>
<p>Define que função GLUT deverá chamar quando ocorrerem eventos de mouse. 
Quando o usuário pressiona ou solta uma dos botões do mouse, cada pressionamento 
ou soltura gera uma chamada de mouse. A função de chamada passada como argumento 
para <tt class="FUNCTION">glutMouseFunc()</tt> deve possuir o seguinte 
protótipo:</p>
<div class="FUNCSYNOPSIS">
<p></p>
<p><code><code class="FUNCDEF">void funcao()</code>(int button, int state, int x, 
int y);</code></p>
<p></p></div>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">void display(void){
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glDisable(GL_POLYGON_STIPPLE);</pre></td></tr></tbody></table>
<p></p></div>
<p>As funções <tt class="FUNCTION">glDisable()</tt> e <tt class="FUNCTION">glEnable()</tt> permitem habilitar diversas habilidades do 
OpenGL. O parâmetro <tt class="PARAMETER"><i>GL_POLYGON_STIPPLE</i></tt> passado 
para essa função desabilita o desenho de polígonos utilizando padrões de 
desenho. Quando <tt class="PARAMETER"><i>GL_POLYGON_STIPPLE</i></tt> é habilitado, 
OpenGL usa o padrão corrente para desenhar.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glPolygonMode(GL_BACK, GL_LINE);
  glColor3f(1.0, 0.0, 0.0);
  glBegin(GL_POLYGON);
  glVertex2i(30,226);  glVertex2i(113,226);
  glVertex2i(113,143); glVertex2i(30,143); 
  glEnd();</pre></td></tr></tbody></table>
<p></p></div>
<p>Neste trecho, a função <tt class="FUNCTION">glPolygonMode()</tt> indica que a 
parte de trás dos polígonos (<tt class="PARAMETER"><i>GL_BACK</i></tt>) será 
desenhada apenas com a linha de contorno externo (<tt class="PARAMETER"><i>GL_LINE</i></tt>), de cor vermelha, conforme especificado 
pela função <tt class="FUNCTION">glColor3f()</tt>. As funções <tt class="FUNCTION">glBegin()</tt>/<tt class="FUNCTION">glEnd()</tt> são usadas agora 
para iniciar o traçado de um polígono (<tt class="PARAMETER"><i>GL_POLYGON</i></tt>) de coordenadas especificadas pela função 
<tt class="FUNCTION">glVertex2i()</tt>. O resultado é o contorno retangular 
vermelho mostrado na <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento.html#FIG-TUXFIG">Figura 
3-2</a>. </p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glPolygonMode(GL_BACK, GL_FILL);
  glColor3f(0.0, 1.0, 0.0);
  glBegin(GL_POLYGON);
  glVertex2i(143,226); glVertex2i(226,226);
  glVertex2i(226,143); glVertex2i(143,143); 
  glEnd();</pre></td></tr></tbody></table>
<p></p></div>
<p>A função <tt class="FUNCTION">glPolygonMode()</tt> indica agora que a parte de 
trás dos polígonos será desenhada apenas com preenchimento sólido (<tt class="PARAMETER"><i>GL_FULL</i></tt>). A cor de desenho agora é (R, G, B) = (0, 
1, 0), de modo que o resultado da execução desse trecho de código é o retângulo 
verde mostrado na <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento.html#FIG-TUXFIG">Figura 
3-2</a>.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glBegin(GL_POLYGON);
  glColor3f(1.0, 0.0, 0.0);  glVertex2i(30,113);  
  glColor3f(0.0, 1.0, 0.0);  glVertex2i(113,113);
  glColor3f(0.0, 0.0, 1.0);  glVertex2i(113,30);  
  glColor3f(1.0, 1.0, 0.0);  glVertex2i(30,30); 
  glEnd();</pre></td></tr></tbody></table>
<p></p></div>
<p>Este trecho de código demonstra uma característica peculiar de preenchimento. 
Como cada vértice é desenhado com uma cor diferente, OpenGL interpola estas 
cores para compor as tonalidades do interior do polígono, gerando um 
preenchimento bastante colorido.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glEnable(GL_POLYGON_STIPPLE);
  glColor3f(1.0, 0.0, 1.0);
  glPolygonStipple(tux);
  glBegin(GL_POLYGON);
  glVertex2i(143,113); glVertex2i(226,113);
  glVertex2i(226,30); glVertex2i(143,30); 
  glEnd();</pre></td></tr></tbody></table>
<p></p></div>
<p>O preenchimento com padrões é agora habilitado pela função <tt class="FUNCTION">glEnable()</tt>. A função <tt class="FUNCTION">glColor3f()</tt> 
define magenta, combinação das tonalidades puras vermelho (R=1) e azul (B=1), 
como a nova cor de desenho. A função <tt class="FUNCTION">glPolygonStipple()</tt> 
define o novo padrão de preenchimento de polígonos, representado pelo vetor 
<font color="red">tux[]</font>. Em seguida, o par <tt class="FUNCTION">glBegin()</tt>/<tt class="FUNCTION">glEnd()</tt> desenha o último 
polígono, preenchindo com o padrão "tux".</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glFlush();</pre></td></tr></tbody></table>
<p></p></div>
<p>A função <tt class="FUNCTION">glFlush()</tt> faz com que qualquer comando 
OpenGL ainda não executado seja executado o mais rápido possível pelo mecanismo 
de exibição. OpenGL freqüentemente executa comandos aos lotes, de modo a tornar 
mais eficiente o processo de exibição, principalmente quando os programas são 
executados via rede. Neste caso, quando os comandos executados um a um, o 
programa pode se tornar ineficiente, considerando as sobrecargas existentes em 
um barramento de rede. Caso o programa desenvolvido seja destinado ao uso 
somente local, a função <tt class="FUNCTION">glFlush()</tt> torna-se 
desnecessária. Entretanto, se o programa é feito para funcionar bem tanto 
localmente quanto em rede, deve ser incluída uma chamada à função <tt class="FUNCTION">glFlush()</tt> no final de cada quadro ou cena.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">void mouse(int button, int state, int x, int y){
  switch (button) {
  case GLUT_LEFT_BUTTON:
	if (state == GLUT_DOWN) {
	  r=(GLfloat)rand()/(RAND_MAX+1.0);
	  g=(GLfloat)rand()/(RAND_MAX+1.0);
	  b=(GLfloat)rand()/(RAND_MAX+1.0);
	  glutPostRedisplay();
	}
	break;
  }
}</pre></td></tr></tbody></table>
<p></p></div>
<p>A função de tratamento de eventos de mouse verifica se algum botão é 
pressionado. Caso o botão esquerdo (<tt class="PARAMETER"><i>GLUT_LEFT_BUTTON</i></tt>) seja pressionado (<tt class="PARAMETER"><i>GLUT_DOWN</i></tt>), serão gerados três valores aleatórios 
para as variáveis <font color="red">r</font>, <font color="red">g</font> e <font color="red">b</font>, na faixa [0,1]. Quando a função <tt class="FUNCTION">glutPostRedisplay()</tt> é executada, a função <tt class="FUNCTION">display</tt> é chamada novamente, fazendo com que a janela 
corrente seja redesenhada e o polígono no canto superior esquerdo dessa janela 
mude de cor.</p></div></div>
<div class="NAVFOOTER">
<hr width="100%" align="left">

<table width="100%" border="0" cellpadding="0" cellspacing="0">
  <tbody>
  <tr>
    <td valign="top" width="33%" align="left"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/desenhando-exercicios.html">Prev</a></td>
    <td valign="top" width="34%" align="middle"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/index2006.html">Home</a></td>
    <td valign="top" width="33%" align="right"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento-outros.html">Next</a></td></tr>
  <tr>
    <td valign="top" width="33%" align="left">Exercícios</td>
    <td valign="top" width="34%" align="middle">&nbsp;</td>
    <td valign="top" width="33%" align="right">Programas relacionados</td></tr></tbody></table></div></body></html>