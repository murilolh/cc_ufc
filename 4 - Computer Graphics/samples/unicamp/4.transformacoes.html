<html><head><title>Transformações geométricas</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta content="MSHTML 6.00.2722.900" name="GENERATOR"><link title="Introdução à computação gráfica com OpenGL" href="http://www.ceset.unicamp.br/%7Emagic/opengl/index2006.html" rel="HOME"><link title="Exercícios" href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento-exercicios.html" rel="PREVIOUS"><link title="Outros" programas="" relacionados="" href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes-braco.html" rel="NEXT"></head><body text="#000000" bgcolor="#ffffff">
<div class="NAVHEADER">
<table width="100%" border="0" cellpadding="0" cellspacing="0">
  <tbody>
  <tr>
    <th colspan="3" align="middle">Introdução à computação gráfica com 
OpenGL</th></tr>
  <tr>
    <td valign="bottom" width="10%" align="left"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento-exercicios.html">Prev</a></td>
    <td valign="bottom" width="80%" align="middle"></td>
    <td valign="bottom" width="10%" align="right"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes-braco.html">Next</a></td></tr></tbody></table>
<hr width="100%" align="left">
</div>
<div class="CHAPTER">
<h1><a name="TRANSFORMACOES">Capítulo 4. Transformações geométricas - cubos4</a></h1>
<div class="TOC">
<dl>
  <dt><b>Índice</b>
  </dt><dt>4.1. <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes.html#TRANSFORMACOES-DESCRICAO">Descrição 
  do programa <tt class="FILENAME">cubos4.c</tt></a>
  </dt><dt>4.2. <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes-braco.html">Transformações geométricas - braço robótico</a>
  </dt><dt>4.3. <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes-outros.html">Outros programas relacionados</a>
  </dt><dt>4.4. <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes-exercicios.html">Exercícios</a></dt></dl></div>
<p>O propósito desta lição é compreender como as transformações geométricas são 
realizadas sobre os objetos em relação a um determinado sistema de coordenadas. 
No OpenGL existem funções para realizar translação, rotação e escalamento, 
bastando apenas ao usuário ajustar os seus parâmetros para obter o efeito 
desejado. Será analisado um programa simples composto de 4 cubos dispostos em uma janela conforme ilustra a <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes.html#FIG-CUBO">Figura 
4-1</a></p>
<div class="FIGURE">
<p><b><a name="FIG-CUBO">Figura 4-1. Programa cubos4</a></b></p>
<p></p><font color="red"><font color="red"><font color="red"></font></font></font>
<p><img src="4.transformacoes_arquivos/tela_cubo4.jpg"></p></div>

<p>O programa que implementa os 4 cubos é mostrado no <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes.html#EXAMPLE-4CUBOS">Exemplo 
4-1</a>. Para finalizar o programa, basta digitar <b class="KEYCAP">ESC</b>. As teclas e 
suas respectivas ações estão definidas na função <tt class="FUNCTION">keyboard()</tt>.</p>
<div class="EXAMPLE">
<p><b><a name="EXAMPLE-BRACO">Exemplo 4-1. programa </a><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/cubos4.c" target="_top"><tt class="FILENAME">cubos4.c</tt></a></b></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

void init(void){
  glClearColor (0.0, 0.0, 0.0, 0.0);
}

void display(void){
  glClear (GL_COLOR_BUFFER_BIT);
  glPushMatrix();

  /* Cubo 1 */
  glPushMatrix();
  glTranslatef (-2.0, 0.0, 0.0);
  glScalef (3.0, 2.0, 5.0);
  glutWireCube (1.0);
  glPopMatrix();
   
  /* Cubo 2 */
  glPushMatrix();
  glRotatef (25.0, 0.0, 0.0, 1.0);
  glTranslatef (2.0, 0.0, 0.0);
  glScalef (2.0, 1.0, 4.0);
  glutWireCube (1.0);
  glPopMatrix();

   /* Cubo 3 */
  glPushMatrix();
  glTranslatef (0.0, 2.0, 0.0);
  glScalef (2.0, 1.0, 4.0);
  glutWireCube (1.0);
  glPopMatrix();

     /* Cubo 4 */
  glPushMatrix();
  glTranslatef (0.0, -2.0, 0.0);
  glScalef (2.0, 1.0, 4.0);
  glutWireCube (1.0);
  glPopMatrix();

  glPopMatrix();
  glutSwapBuffers();
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef (0.0, 0.0, -10.0);
}
void keyboard(unsigned char key, int x, int y){
  switch (key) {
  case 27:                                         // tecla Esc (encerra o programa)
	exit(0);
	break;
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (500, 500); 
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  init ();
  glutDisplayFunc(display); 
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}</pre></td></tr></tbody></table></div>
<p>Para compilar e executar o programa <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/cubos4.c" target="_top"><tt class="FILENAME">cubos4.c</tt></a>, salve-o juntamente com o 
arquivo <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/Makefile" target="_top">Makefile</a> em um diretório e execute a seguinte seqüência de 
comandos:</p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="SCREEN"><tt class="PROMPT">$</tt> <b class="COMMAND">make</b> <span class="OPTION">cubos4</span>
<tt class="PROMPT">$</tt> <b class="COMMAND">./cubos4</b></pre></td></tr></tbody></table>
<div class="SECT1">
<h1 class="SECT1"><a name="TRANSFORMACOES-DESCRICAO">4.1. Descrição do programa <tt class="FILENAME">cubos4.c</tt></a></h1>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">void init(void){
  glClearColor (0.0, 0.0, 0.0, 0.0);
}</pre></td></tr></tbody></table>
<p></p></div>
<p>Especifica as intensidade de vermelho (RED), verde (GREEN) e azul
(BLUE) utilizadas para limpar a janela. Neste caso, a janela terá cor
de fundo preta. O último
parâmetro é o canal alfa, utilizado para tratar com transparências.
</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">void display(void)
{
  glClear (GL_COLOR_BUFFER_BIT);
  glPushMatrix();</pre></td></tr></tbody></table>
<p></p></div>
<p>Uma vez que as transformações geométricas no espaço são representadas por 
matrizes, o uso de uma pilha de matrizes de transformação ajuda a lembrar a 
seqüência de transformações realizadas. No OpenGL, esta facilidade é provida 
pelas funções <tt class="FUNCTION">glPushMatrix()</tt>, que insere a matriz de 
transformação corrente na pilha, e <tt class="FUNCTION">glPopMatrix()</tt>, que 
retira a matriz do topo da pilha e torna esta última a matriz de transformação 
corrente. Neste exemplo, a função <tt class="FUNCTION">glPushMatrix()</tt> serve 
para lembrar os parâmetros de translação, rotação e escalamento no início das 
operações de desenho.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  
  /* Cubo 1 */
  glPushMatrix();
  glTranslatef (-2.0, 0.0, 0.0);
  glScalef (3.0, 2.0, 5.0);
  glutWireCube (1.0);
  glPopMatrix();
</pre></td></tr></tbody></table>
<p></p></div>
<p> O conjunto de transformações sobre o primeiro cubo a ser desenhado é delimitado pelo 
<tt class="FUNCTION">glPushMatrix()</tt> e <tt class="FUNCTION">glPopMatrix()</tt>. 
A origem do sistema de coordenadas é levado para o ponto (x,y,z)=(-2.0,0.0,0.0) 
através da função <tt class="FUNCTION">glTranslatef()</tt>, definindo a coordenada 
de origem (pivô) para o desenho do cubo. Em seguida, usando a função <tt class="FUNCTION">glScalef()</tt>, o sistema de coordenadas é ampliado em (Sx,Sy,Sz)=(3.0,2.0,5.0), 
e, finalmente, desenhado <i>um cubo aramado</i> através de <tt class="FUNCTION">glutWireCube()</tt>.</p>


<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  
  /* Cubo 2 */
  glPushMatrix();
  glRotatef (25.0, 0.0, 0.0, 1.0);
  glTranslatef (2.0, 0.0, 0.0);
  glScalef (2.0, 1.0, 4.0);
  glutWireCube (1.0);
  glPopMatrix();
</pre></td></tr></tbody></table>
<p></p></div>

<p>A função <tt class="FUNCTION">glRotatef()</tt> possui o seguinte protótipo:</p>
<div class="FUNCSYNOPSIS">
<p></p>
<p><code><code class="FUNCDEF">void glRotatef</code>(GLfloat angle, GLfloat x, 
GLfloat y, GLfloat z);</code></p>
<p></p></div>
<p>Quando chamada, <tt class="FUNCTION">glRotatef()</tt> efetua uma rotação de <tt class="PARAMETER"><i>angle</i></tt> graus no sistema de coordenadas na direção 
contra o sentido do relógio em torno de um vetor que vai da origem ao ponto 
(x,y,z)</p>

<p> Observe que os cubos 3 e 4 não são também rotacionados mesmo estando após o uso da função <tt class="FUNCTION">glRotatef()</tt> 
sobre o cubo 2, em função da delimitação da pilha de execução delimitada por <tt class="FUNCTION">glPushMatrix()</tt> e 
<tt class="FUNCTION">glPopMatrix()</tt>.</p>


<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  
   /* Cubo 3 */
  glPushMatrix();
  glTranslatef (0.0, 2.0, 0.0);
  glScalef (2.0, 1.0, 4.0);
  glutWireCube (1.0);
  glPopMatrix();
</pre></td></tr></tbody></table>
<p></p></div>

<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  
     /* Cubo 4 */
  glPushMatrix();
  glTranslatef (0.0, -2.0, 0.0);
  glScalef (2.0, 1.0, 4.0);
  glutWireCube (1.0);
  glPopMatrix();
</pre></td></tr></tbody></table>
<p></p></div>

<p> Os outros dois cubos são desenhados, segundo às mesmas orientações dadas acima.</p>

<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glPopMatrix();
  glutSwapBuffers();</pre></td></tr></tbody></table>
<p></p></div>
<p>A função <tt class="FUNCTION">glPopMatrix()</tt> remove a matriz de 
transformação do topo da pilha, fazendo-a corrente, retornando assim o sistema 
de coordenadas original. Quando <tt class="FUNCTION">glutSwapBuffers()</tt> é 
chamada, os buffers de desenho e de apresentação são alternados e a nova imagem 
dos cubos é apresentada.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">void reshape (int w, int h)
{
  glViewport (0, 0, (GLsizei) w, (GLsizei) h); </pre></td></tr></tbody></table>
<p></p></div>
<p>Define a área dentro da janela de desenho no sistema de coordenadas atual, 
origem (x,y), largura (w) e altura (h), que OpenGL pode utilizar para efetuar 
desenhos. Este trecho de código permite que toda a área da janela possa ser 
utilizada quando a janela sofrer redimensionamento.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);</pre></td></tr></tbody></table>
<p></p></div>
<p>A função <tt class="FUNCTION">glMatrixMode()</tt> especifica a pilha de 
matrizes que será o alvo das operações matriciais subseqüentes; neste caso, a 
pilha de matrizes de projeção. A função <tt class="FUNCTION">glLoadIdentity()</tt> 
inicia a matriz de projeção corrente como a matriz identidade. A função <tt class="FUNCTION">gluPerspective()</tt> define a transformação de perspectiva usada 
no exemplo. Projeções geométricas não são alvo desta lição e por enquanto não 
serão estudadas.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef (0.0, 0.0, -10.0);</pre></td></tr></tbody></table>
<p></p></div>
<p>A função <tt class="FUNCTION">glMatrixMode()</tt> especifica agora que a pilha 
de matrizes de <i class="FOREIGNPHRASE">modelview</i>, usadas para definir 
translação, rotação e escalamento, será o alvo das transformações subseqüentes. 
A função <tt class="FUNCTION">glLoadIdentity()</tt> inicia a matriz de <i class="FOREIGNPHRASE">modelview</i> corrente como a matriz identidade. Finalmente, 
o objeto é deslocado em -10 unidades para o fundo da tela, melhorando a sua 
visualização.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glutReshapeFunc(reshape);</pre></td></tr></tbody></table>
<p></p></div>
<p>Especifica a função de retorno para redimensionamento de janela, possuindo o 
seguinte protótipo:</p>
<div class="FUNCSYNOPSIS">
<p></p>
<p><code><code class="FUNCDEF">funcao</code>(int width, int height);</code></p>
<p></p></div></div></div>
<div class="NAVFOOTER">
<hr width="100%" align="left">

<table width="100%" border="0" cellpadding="0" cellspacing="0">
  <tbody>
  <tr>
    <td valign="top" width="33%" align="left"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/preenchimento-exercicios.html">Prev</a></td>
    <td valign="top" width="34%" align="middle"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/index2006.html">Home</a></td>
    <td valign="top" width="33%" align="right"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes-braco.html">Next</a></td></tr>
  <tr>
    <td valign="top" width="33%" align="left">Preenchimento - Exercícios</td>
    <td valign="top" width="34%" align="middle">&nbsp;</td>
    <td valign="top" width="33%" align="right">Transformações - Braço</td></tr></tbody></table></div></body></html>