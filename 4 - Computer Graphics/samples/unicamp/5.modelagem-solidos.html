<html><head><title>Modelagem de Sólidos</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta content="MSHTML 6.00.2722.900" name="GENERATOR"><link title="Introdução à computação gráfica com OpenGL" href="http://www.ceset.unicamp.br/%7Emagic/opengl/index2006.html" rel="HOME"><link title="Exercícios" href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes-exercicios.html" rel="PREVIOUS"><link title="Exercícios" href="http://www.ceset.unicamp.br/%7Emagic/opengl/modelagem-outros.html" rel="NEXT"></head><body text="#000000" bgcolor="#ffffff">
<div class="NAVHEADER">
<table width="100%" border="0" cellpadding="0" cellspacing="0">
  <tbody>
  <tr>
    <th colspan="3" align="middle">Introdução à computação gráfica com 
OpenGL</th></tr>
  <tr>
    <td valign="bottom" width="10%" align="left"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes-exercicios.html">Prev</a></td>
    <td valign="bottom" width="80%" align="middle"></td>
    <td valign="bottom" width="10%" align="right"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/modelagem-outros.html">Next</a></td></tr></tbody></table>
<hr width="100%" align="left">
</div>
<div class="CHAPTER">
<h1><a name="MODELAGEM-SOLIDOS">Capítulo 5. Modelagem de Sólidos</a></h1>
<div class="TOC">
<dl>
  <dt><b>Índice</b>
  </dt><dt>5.1. <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/modelagem-solidos.html#MODELAGEM-DESCRICAO">Descrição 
  do programa <tt class="FILENAME">jato.c</tt></a>
  </dt><dt>5.2. <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/modelagem-outros.html">Outros Programas Relacionados</a>
  </dt><dt>5.3. <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/modelagem-exercicios.html">Exercícios</a></dt></dl></div>
<p>O propósito desta lição é introduzir o uso de listas de apresentação (<i class="FOREIGNPHRASE">display lists</i>), mapeamento de texturas e o uso de teclas 
especiais.</p>
<p>As listas de apresentação permitem que vários comandos sejam executados de 
uma vez só apenas com uma chamada da lista. Cada lista de apresentação precisa 
ser armazenada apenas uma vez, de modo que quando uma chamada é realizada, todos 
os comandos declarados nesta lista já estarão presentes máquina interna do 
OpenGL, tornando o processo de desenho mais fácil e com performance melhorada. 
</p>
<p>O mapeamento de texturas nos objetos torna a cena mais realística, 
principalmente quando texturas de objetos reais são utilizadas. A maioria das 
texturas existentes não podem ser geradas de forma artificial. Quando isto é 
possível, os algoritmos utilizados são complexos e computacionamente custosos. 
Assim, geramente as texturas são lidas de arquivos de imagens digitais 
capturadas com dispositivos de arquisição de dados.</p>
<p>Diversos formatos podem ser usados para armazenar uma imagem digital: bmp, 
jpeg, gif, tif, tga etc. Neste curso usaremos o formato IRIS RGB, criado pela 
Silicon Graphics. As funções que permitem a leitura de arquivos RGB e seus 
respectivos protótipos estão implementados nos arquivos <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/image.c" target="_top"><tt class="FILENAME">image.c</tt></a> e <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/image.h" target="_top"><tt class="FILENAME">image.h</tt></a>.</p>
<p>O objeto utilizado nesta lição será um modelo simples de uma avião a jato com 
fuselagem texturizada, imóvel sobre um plano com textura montanhosa, como mostra 
a <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/modelagem-solidos.html#FIG-MODELAGEM-JATO-3D">Figura 
5-1</a>. As vistas laterais, superior e frontal estão esquematizadas na <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/modelagem-solidos.html#FIG-MODELAGEM-JATO">Figura 
5-2</a>.</p>
<div class="FIGURE">
<p><b><a name="FIG-MODELAGEM-JATO-3D">Figura 5-1. Avião a jato 
tridimensional</a></b></p>
<p><img src="5.modelagem-solidos_arquivos/modelagem-jato-3d.jpg"></p></div>
<div class="FIGURE">
<p><b><a name="FIG-MODELAGEM-JATO">Figura 5-2. Vistas laterais, superior e frontal 
do avião a jato</a></b></p>
<p><img src="5.modelagem-solidos_arquivos/modelagem-jato.jpg"></p></div>
<p>Neste exemplo, o olhar do observador é fixo aproximadamente no centro do 
avião, de modo que apenas a posição do observador é alterada para o usuário 
poder visualizar diversas tomadas da cena.</p>
<p>O programa usado para modelar o avião é mostrado no <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/modelagem-solidos.html#EXAMPLE-MODELAGEM-SOLIDOS">Exemplo 
5-1</a>. As teclas <b class="KEYCAP">LEFT</b> e <b class="KEYCAP">RIGHT</b> servem 
para rotacionar a posição do observador em torno do eixo y contra e a favor do 
sentido dos ponteiros do relógio, respectivamente. A distância entre o 
observador e o centro de rotação (raio de observação) é alterado pelas teclas <b class="KEYCAP">r</b> e <b class="KEYCAP">R</b>, que aumentam o diminuem o seu valor, 
respectivamente. As teclas <b class="KEYCAP">UP</b> e <b class="KEYCAP">DOWN</b>, 
controlam a altitude do observador (no eixo y). A tecla <b class="KEYCAP">t</b> 
habilita ou desabilita o uso de texturas. Para finalizar o programa, basta 
digitar <b class="KEYCAP">ESC</b>. As teclas e suas respectivas ações estão 
definidas nas funções <tt class="FUNCTION">keyboard()</tt> e <tt class="FUNCTION">special()</tt>.</p>
<div class="EXAMPLE">
<p><b><a name="EXAMPLE-MODELAGEM-SOLIDOS">Exemplo 5-1. programa </a><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/jato.c" target="_top"><tt class="FILENAME">jato.c</tt></a></b></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;GL/glut.h&gt;
#include "image.h"

#define PI 3.1415

#define COORD_TEXTURA_PLANO 1.0
#define COORD_TEXTURA_AVIAO 1.0
#define COR_DO_PLANO 0.52,0.52,0.78,1.0
#define COR_DO_AVIAO 0.3,0.52,0.18,1.0
#define TEXTURA_DO_PLANO "montanhas.rgb"
#define TEXTURA_DO_AVIAO "camuflagem.rgb"

GLint WIDTH =800;
GLint HEIGHT=600;

GLfloat obs[3]={0.0,7.0,0.0};
GLfloat look[3]={0.0,3.0,0.0};
GLuint  textura_plano;
GLuint  textura_aviao;

GLshort texturas=1;
GLfloat tetaxz=0;
GLfloat raioxz=6;
GLuint  jato;

GLfloat ctp[4][2]={
  {-COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO},
  {-COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO}
};

GLfloat cta[4][2]={
  {-COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO},
  {-COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO}
};


void reshape(int width, int height){
  WIDTH=width;
  HEIGHT=height;
  glViewport(0,0,(GLint)width,(GLint)height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(70.0,width/(float)height,0.1,30.0);
  glMatrixMode(GL_MODELVIEW);
}

void compoe_jato(void){
  GLUquadricObj *quadric;

  GLfloat asa[][3]={
    {-4.0,0.0,0.0},
    {+4.0,0.0,0.0},
    {0.0,0.0,3.0}
  };

  GLfloat cauda[][3]={
    {0.0,0.0,0.0},
    {0.0,2.0,-1.0},
    {0.0,2.0,0.0},
    {0.0,0.0,2.0}
  };
  /* inicia a composicao do jato */
  jato = glGenLists(1);
  glNewList(jato, GL_COMPILE);

  /* asas */
  glBegin(GL_TRIANGLES); 
  glTexCoord2fv(cta[0]); glVertex3fv(asa[0]);
  glTexCoord2fv(cta[1]); glVertex3fv(asa[1]);
  glTexCoord2fv(cta[3]); glVertex3fv(asa[2]);
  glEnd();
  
  /* corpo */
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  gluCylinder(quadric, 0.5, 0.5, 4, 12, 3);
  
  /* nariz */
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  glPushMatrix();
  glTranslatef(0,0,4);
  gluCylinder(quadric, 0.5, 0.0, 1.5, 12, 3);
  glPopMatrix();

  /* cauda */
  glBegin(GL_POLYGON); 
  glTexCoord2fv(cta[0]); glVertex3fv(cauda[0]);
  glTexCoord2fv(cta[1]); glVertex3fv(cauda[1]);
  glTexCoord2fv(cta[2]); glVertex3fv(cauda[2]);
  glTexCoord2fv(cta[3]); glVertex3fv(cauda[3]);
  glEnd();

  /* cabine do piloto */
  glTranslatef(0,0.3,3.5);
  glPushMatrix();
  glScalef(0.7,0.7,2.0);
  quadric=gluNewQuadric();
  glColor3f(0.3,0.5,1);
  glDisable(GL_TEXTURE_2D);
  gluSphere(quadric,0.5,12,12);
  glPopMatrix();

  /* termina a composicao do jato*/
  glEndList();
}

void display(void){
  glEnable(GL_DEPTH_TEST);
  
  glDepthMask(GL_TRUE);
  glClearColor(1.0,1.0,1.0,1.0);
  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
  
  glPushMatrix();

  /* calcula a posicao do observador */
  obs[0]=raioxz*cos(2*PI*tetaxz/360);
  obs[2]=raioxz*sin(2*PI*tetaxz/360);
  gluLookAt(obs[0],obs[1],obs[2],look[0],look[1],look[2],0.0,1.0,0.0);

  /* habilita/desabilita uso de texturas*/
  if(texturas){
    glEnable(GL_TEXTURE_2D);  
  }
  else{
    glDisable(GL_TEXTURE_2D);
  }

  glColor4f(COR_DO_PLANO);
  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);
  glBindTexture(GL_TEXTURE_2D,textura_plano);
   
  glBegin(GL_QUADS);
  glTexCoord2fv(ctp[0]);  glVertex3f(-10,0,10);
  glTexCoord2fv(ctp[1]);  glVertex3f(10,0,10);
  glTexCoord2fv(ctp[2]);  glVertex3f(10,0,-10);
  glTexCoord2fv(ctp[3]);  glVertex3f(-10,0,-10);
  glEnd();
  glTranslatef(0.0,2.0,-3.0);

  glColor4f(COR_DO_AVIAO);
  glBindTexture(GL_TEXTURE_2D,textura_aviao);
  glCallList(jato);

  glPopMatrix();
  glutSwapBuffers();
}


void special(int key, int x, int y){
  switch (key) {
  case GLUT_KEY_UP:
    obs[1]=obs[1]+1;
    glutPostRedisplay();
    break;
  case GLUT_KEY_DOWN:
    obs[1] =obs[1]-1;
    glutPostRedisplay();
    break;
  case GLUT_KEY_LEFT:
    tetaxz=tetaxz+2;
    glutPostRedisplay();
    break;
  case GLUT_KEY_RIGHT:
    tetaxz=tetaxz-2;
    glutPostRedisplay();
    break;
  }
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
  case 27:
    exit(0);
    break;
  case 't':
    texturas = !texturas;
    glutPostRedisplay();
    break;
  case 'r':
    raioxz=raioxz+1;
    glutPostRedisplay();
    break;
  case 'R':
    raioxz=raioxz-1;
    if(raioxz==0){
      raioxz=1;
    }
    glutPostRedisplay();
    break;
  }
}

void carregar_texturas(void){
  IMAGE *img;
  GLenum gluerr;

  /* textura do plano */
  glGenTextures(1, &amp;textura_plano);
  glBindTexture(GL_TEXTURE_2D, textura_plano);
  
  if(!(img=ImageLoad(TEXTURA_DO_PLANO))) {
    fprintf(stderr,"Error reading a texture.\n");
    exit(-1);
  }

  gluerr=gluBuild2DMipmaps(GL_TEXTURE_2D, 3, 
			   img-&gt;sizeX, img-&gt;sizeY, 
			   GL_RGB, GL_UNSIGNED_BYTE, 
			   (GLvoid *)(img-&gt;data));
  if(gluerr){
    fprintf(stderr,"GLULib%s\n",gluErrorString(gluerr));
    exit(-1);
  }

  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);

  /* textura do aviao */
  glGenTextures(1, &amp;textura_aviao);
  glBindTexture(GL_TEXTURE_2D, textura_aviao);

  
  if(!(img=ImageLoad(TEXTURA_DO_AVIAO))) {
    fprintf(stderr,"Error reading a texture.\n");
    exit(-1);
  }

  gluerr=gluBuild2DMipmaps(GL_TEXTURE_2D, 3, 
			   img-&gt;sizeX, img-&gt;sizeY, 
			   GL_RGB, GL_UNSIGNED_BYTE, 
			   (GLvoid *)(img-&gt;data));
  if(gluerr){
    fprintf(stderr,"GLULib%s\n",gluErrorString(gluerr));
    exit(-1);
  }

  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);
  
}

void init(){
  carregar_texturas();
  compoe_jato();
  glShadeModel(GL_FLAT);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_TEXTURE_2D);
}

int main(int argc,char **argv){
  glutInitWindowPosition(0,0);
  glutInitWindowSize(WIDTH,HEIGHT);
  glutInit(&amp;argc,argv);
  glutInitDisplayMode(GLUT_RGB|GLUT_DEPTH|GLUT_DOUBLE);

  if(!glutCreateWindow("Avião a jato")) {
    fprintf(stderr,"Error opening a window.\n");
    exit(-1);
  }

  init();
  
  glutKeyboardFunc(keyboard);
  glutSpecialFunc(special);
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutMainLoop();

  return(0);
}</pre></td></tr></tbody></table></div>
<p>Para compilar e executar o programa <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/jato.c" target="_top"><tt class="FILENAME">jato.c</tt></a>, salve-o juntamente com os 
arquivo <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/Makefile.modelagem" target="_top">Makefile.modelagem</a>, <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/image.c" target="_top">image.c</a>, <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/image.h" target="_top">image.h</a>, <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/montanhas.rgb" target="_top">montanhas.rgb</a> e <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/camuflagem.rgb" target="_top">camuflagem.rgb</a> em um diretório e execute a seguinte seqüência de 
comandos:</p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="SCREEN"><tt class="PROMPT">$</tt> <b class="COMMAND">make</b> <span class="OPTION">-f</span> <span class="OPTION">Makefile.modelagem</span> <span class="OPTION">jato</span>
<tt class="PROMPT">$</tt> <b class="COMMAND">./jato</b></pre></td></tr></tbody></table>
<div class="SECT1">
<h1 class="SECT1"><a name="MODELAGEM-DESCRICAO">5.1. Descrição do programa <tt class="FILENAME">jato.c</tt></a></h1>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">#define COORD_TEXTURA_PLANO 1.0
#define COORD_TEXTURA_AVIAO 1.0
#define COR_DO_PLANO 0.52,0.52,0.78,1.0
#define COR_DO_AVIAO 0.3,0.52,0.18,1.0
#define TEXTURA_DO_PLANO "montanhas.rgb"
#define TEXTURA_DO_AVIAO "camuflagem.rgb"</pre></td></tr></tbody></table>
<p></p></div>
<p>Define as cores e coordenadas das texturas do plano e do avião, além dos 
nomes dos arquivos que contém as imagens das texturas.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">GLint WIDTH =320;
GLint HEIGHT=240;</pre></td></tr></tbody></table>
<p></p></div>
<p>Especifica a largura (<i class="FOREIGNPHRASE">WIDTH</i>) e a altura (<i class="FOREIGNPHRASE">HEIGHT</i>) iniciais da janela de desenho.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">GLfloat obs[3]={0.0,7.0,0.0};
GLfloat look[3]={0.0,3.0,0.0};</pre></td></tr></tbody></table>
<p></p></div>
<p>As coordenadas da posição do observador é armazenada no vetor <font color="red">obs[]</font> e as do ponto para onde o observador olha é armazenado no 
vetor <font color="red">look[]</font>. De acordo com estes vetores, o observador 
encontra-se no ponto (x,y,z)=(0,7,0) e está olhando para o ponto 
(x,y,z)=(0,3,0).</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">GLuint  textura_plano;
GLuint  textura_aviao;</pre></td></tr></tbody></table>
<p></p></div>
<p>As variáveis <font color="red">textura_plano</font> e <font color="red">textura_aviao</font> armazenam os identificadores das texturas do 
plano e do avião.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">GLshort texturas=1;
GLfloat tetaxz=0;
GLfloat raioxz=6;
GLuint  jato;</pre></td></tr></tbody></table>
<p></p></div>
<p>A variável <font color="red">texturas</font> é usada para habilitar/desabilitar 
o uso de texturas nos objetos. As variáveis <font color="red">tetaxz</font> e 
<font color="red">raioxz</font> armazenam o ângulo de rotação do ponto de 
observação e a distância entre o observador e a origem, respectivamente. A 
variável <font color="red">jato</font> amazena o identificador para a lista de 
apresentação do avião a jato.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">GLfloat ctp[4][2]={
  {-COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO},
  {-COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO}
};

GLfloat cta[4][2]={
  {-COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO},
  {-COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO}
};</pre></td></tr></tbody></table>
<p></p></div>
<p>Quando uma textura é carregada, o OpenGL guarda em uma matriz e assume 
coordenadas (0,0), (1,0), (1,1) e (0,1) para os quatro cantos da textura. Neste 
exemplo, é assumido a repetição das texturas, de modo a poder cobrir todo o 
objeto. As coordenadas especificadas neste trecho de código indicam que o objeto 
será carimbado com sua respectiva textura e que as coordenadas das texturas que 
serão usadas para criar os carimbos do plano e do avião serão <font color="red">ctp[]</font> e <font color="red">cta[]</font>, respectivamente. </p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  GLUquadricObj *quadric;</pre></td></tr></tbody></table>
<p></p></div>
<p>Quádricas são superfícies definidas pela seguinte equação 
a<sub>1</sub>x<sup>2</sup> + a<sub>2</sub>y<sup>2</sup> 
+a<sub>3</sub>z<sup>2</sup> + a<sub>4</sub>xy + a<sub>5</sub>yz + 
a<sub>6</sub>xz + a<sub>7</sub>x + a<sub>8</sub>y +a<sub>9</sub>z + 
a<sub>10</sub>. Os tipos de quádricas mais conhecidos são os cones, os 
cilindros, as esferas e os discos, modelados pelo ajuste adequado dos parâmetros 
a<sub>i</sub>. Estes objetos são guardados em uma estrutura de dados do tipo 
<span class="TYPE">GLUquadricObj</span>.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  GLfloat asa[][3]={
    {-4.0,0.0,0.0},
    {+4.0,0.0,0.0},
    {0.0,0.0,3.0}
  };

  GLfloat cauda[][3]={
    {0.0,0.0,0.0},
    {0.0,2.0,-1.0},
    {0.0,2.0,0.0},
    {0.0,0.0,2.0}
  };</pre></td></tr></tbody></table>
<p></p></div>
<p>As variáveis <font color="red">asa[][]</font> e <font color="red">cauda[][]</font> armazenam as coordenadas dos polígonos que compõem a 
asa e a cauda do avião, respectivamente.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  jato = glGenLists(1);
  glNewList(jato, GL_COMPILE);</pre></td></tr></tbody></table>
<p></p></div>
<p>A função <tt class="FUNCTION">glGenLists()</tt> aloca um conjunto contínuo de 
listas de apresentação vazias e retorna o identificador utilizado para a lista 
alocada. Neste exemplo, o conjunto contém apenas uma lista de apresentação. Mais 
listas poderão ser alocadas com subseqüentes chamadas à mesma função. </p>
<p>A função <tt class="FUNCTION">glNewList()</tt> especifica o início de uma lista 
de apresentação. Todos os comandos executados até a chamada de <tt class="FUNCTION">glEndList()</tt> ficarão armazenados nesta lista. A função <tt class="FUNCTION">glNewList()</tt> possui o seguinte protótipo:</p>
<div class="FUNCSYNOPSIS">
<p></p>
<p><code><code class="FUNCDEF">void glNewList</code>(GLUint list, GLenum 
mode);</code></p>
<p></p></div>
<p><tt class="PARAMETER"><i>list</i></tt> é um número inteiro maior que zero que 
identifica de forma única a lista de apresentação. O parâmetro <tt class="PARAMETER"><i>mode</i></tt> pode assumir os valores <tt class="PARAMETER"><i>GL_COMPILE</i></tt> e <tt class="PARAMETER"><i>GL_COMPILE_AND_EXECUTE</i></tt>. O primeiro apenas armazena 
os comandos na lista; o segundo executa os comandos enquanto são armazenados na 
lista.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  gluCylinder(quadric, 0.5, 0.5, 4, 12, 3);</pre></td></tr></tbody></table>
<p></p></div>
<p>Inicia, usando a função <tt class="FUNCTION">gluNewQuadric()</tt>, a primeira 
das quádricas do exemplo: o corpo do avião. Para esta quádrica, o mapeamento de 
textura está habilitado. A função <tt class="FUNCTION">gluCylinder()</tt> possui o 
seguinte protótipo:</p>
<div class="FUNCSYNOPSIS">
<p></p>
<p><code><code class="FUNCDEF">void gluCylinder</code>(GLUquadric* quad, GLdouble 
base, GLdouble top, GLdouble height, GLint slices, GLint stacks);</code></p>
<p></p></div>
<p>O parâmetro <tt class="PARAMETER"><i>quad</i></tt> é o objeto de quádrica; <tt class="PARAMETER"><i>base</i></tt>, <tt class="PARAMETER"><i>top</i></tt> e <tt class="PARAMETER"><i>height</i></tt> especificam o raio da base, o raio do topo e 
a altura do cilindro, respectivamente; <tt class="PARAMETER"><i>slices</i></tt> 
<tt class="PARAMETER"><i>stacks</i></tt> especificam o número de subdivisões ao 
redor do eixo z e ao longo do mesmo.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  obs[0]=raioxz*cos(2*PI*tetaxz/360);
  obs[2]=raioxz*sin(2*PI*tetaxz/360);
  gluLookAt(obs[0],obs[1],obs[2],look[0],look[1],look[2],0.0,1.0,0.0);</pre></td></tr></tbody></table>
<p></p></div>
<p>Na função <tt class="FUNCTION">display()</tt> as coordenadas x e z da posição 
do observador são calculadas e a função <tt class="FUNCTION">gluLookAt()</tt> é 
chamada para mudar a posição do observador. Recomenda-se a execução do Tutorial do <i>Nate Robins</i> (ver TelEduc) relacionado
ao uso da função <tt class="FUNCTION">gluLookAt()</tt>.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  if(texturas){
    glEnable(GL_TEXTURE_2D);  
  }
  else{
    glDisable(GL_TEXTURE_2D);
  }</pre></td></tr></tbody></table>
<p></p></div>
<p>Aqui o mapeamento de texturas é habilitado ou desabilitado, de acordo com o 
estado da variável <font color="red">texturas</font>. Quando o mapeamento de 
texturas é desabilitado, o objeto é desenhado utilizando as cores especificadas 
pela função <tt class="FUNCTION">glColor*()</tt>.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);</pre></td></tr></tbody></table>
<p></p></div>
<p>A função <tt class="FUNCTION">glTexEnvf()</tt> define os parâmetros do ambiente 
de textura. O primeiro parâmetro é sempre <tt class="PARAMETER"><i>GL_TEXTURE_ENV</i></tt>; o segundo parâmetro é sempre <tt class="PARAMETER"><i>GL_TEXTURE_ENV_MODE</i></tt> e o terceiro especifica como a 
textura será combinada com a cor para formar a superfície do objeto, neste caso 
substituindo completamente a cor do objeto pela textura corrente.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glBindTexture(GL_TEXTURE_2D,textura_plano);
   
  glBegin(GL_QUADS);
  glTexCoord2fv(ctp[0]);  glVertex3f(-10,0,10);
  glTexCoord2fv(ctp[1]);  glVertex3f(10,0,10);
  glTexCoord2fv(ctp[2]);  glVertex3f(10,0,-10);
  glTexCoord2fv(ctp[3]);  glVertex3f(-10,0,-10);
  glEnd();</pre></td></tr></tbody></table>
<p></p></div>
<p><tt class="FUNCTION">glBindTexture()</tt> carrega a textura bidimensional 
associada com a variável <font color="red">textura_plano</font>. Em seguida, um 
plano é desenhado usando <tt class="PARAMETER"><i>GL_QUADS</i></tt>. Observe que, 
antes de desenhar cada vértice, a função <tt class="FUNCTION">glTexCoord2fv()</tt> 
é chamada para definir as coordenadas de textura correntes.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">void carregar_texturas(void){
  IMAGE *img;
  GLenum gluerr;

  /* textura do plano */
  glGenTextures(1, &amp;textura_plano);
  glBindTexture(GL_TEXTURE_2D, textura_plano);
  
  if(!(img=ImageLoad(TEXTURA_DO_PLANO))) {
    fprintf(stderr,"Error reading a texture.\n");
    exit(-1);
  }</pre></td></tr></tbody></table>
<p></p></div>
<p>A carga das texturas é feita com uso da função <tt class="FUNCTION">ImageLoad()</tt>, implementada em <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/image.c" target="_top"><tt class="FILENAME">image.c</tt></a> e definida em <a href="http://www.ceset.unicamp.br/%7Emagic/opengl/image.h" target="_top"><tt class="FILENAME">image.h</tt></a>. Esta função recebe como 
parâmetro o nome do arquivo com a imagem da textura e retorna um ponteiro para 
uma estrutura de dados do tipo <span class="TYPE">IMAGE</span>.</p>
<p>A função <tt class="FUNCTION">glGenTextures()</tt> gera 1 nome de textura em 
<font color="red">textura_plano</font>. Um nome de textura é qualquer inteiro 
diferente de zero que identifique de forma única a textura. Assim, texturas 
diferentes possuem nomes diferentes. Caso o segundo parâmetro desta função seja 
um vetor de elementos <span class="TYPE">GLuint</span>, mais nomes de textura 
podem ser gerados, um para cada elemento deste vetor.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  gluerr=gluBuild2DMipmaps(GL_TEXTURE_2D, 3, 
			   img-&gt;sizeX, img-&gt;sizeY, 
			   GL_RGB, GL_UNSIGNED_BYTE, 
			   (GLvoid *)(img-&gt;data));</pre></td></tr></tbody></table>
<p></p></div>
<p>Mipmaps são séries de versões em baixa resolução de um mapa de textura. 
Geralmente é utilizado para texturizar um objeto cuja resolução na tela difere 
da resolução no mapa de textura. Por exemplo, um objeto próximo da tela pode ser 
desenhado utilizando uma resolução de textura maior que um objeto distante da 
tela. O uso de mipmaps evita o efeito de serrilhamento (<i class="FOREIGNPHRASE">aliasing</i>) e outros distúrbios de exibição quando um 
objeto é aproximado ou afastado da tela.</p>
<p>Mipmaps bidimensionais são construídos com a função <tt class="FUNCTION">gluBuild2dMipmaps()</tt>, que possuiu seguinte protótipo:</p>
<div class="FUNCSYNOPSIS">
<p></p>
<p><code><code class="FUNCDEF">void gluBuild2dMipmaps</code>(GLenum target, GLint 
internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const 
void *data);</code></p>
<p></p></div>
<p><tt class="PARAMETER"><i>target</i></tt> indica o tipo de mipmaps que se deseja 
construir - neste caso uma textura bidimensional. <tt class="PARAMETER"><i>internalFormat</i></tt> indica o tipo de armazenagem interna 
do arquivo de textura. Neste exemplo, as texturas são imagens RGB, incluindo 3 
(três) componentes de cor. Os parâmetros <tt class="PARAMETER"><i>width</i></tt> e 
<tt class="PARAMETER"><i>height</i></tt> especificam a largura e a altura do dado. 
Ambas estas dimensões devem ser potências de 2. <tt class="PARAMETER"><i>format</i></tt> especifica o formato dos pixels do dado 
(RGB). <tt class="PARAMETER"><i>type</i></tt> especifica o tipo de dado 
representado no vetor de dados. <tt class="PARAMETER"><i>data</i></tt> especifica 
o ponteiro para a posição de memória onde os dados de textura residem. </p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);</pre></td></tr></tbody></table>
<p></p></div>
<p>A função <tt class="FUNCTION">glTexParameterf()</tt> define uma série de 
parâmetros que controlam como uma textura é tratada e aplicada a um fragmento de 
um dado objeto. Aqui, através dos parâmetros <tt class="PARAMETER"><i>GL_TEXTURE_WRAP_S</i></tt> e <tt class="PARAMETER"><i>GL_TEXTURE_WRAP_T</i></tt>, a função define que nas direções 
s e t (coordenadas) a textura deverá será repetida no objeto.</p>
<div class="INFORMALEXAMPLE">
<p></p>
<table width="100%" bgcolor="#e0e0e0" border="0">
  <tbody>
  <tr>
    <td><pre class="PROGRAMLISTING">  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);</pre></td></tr></tbody></table>
<p></p></div>
<p>Neste trecho do código, as funções <tt class="FUNCTION">glTexParameterf()</tt> 
define os tipos de filtro usados quando a textura for minimizada ou maximizada. 
Pelo parâmetro <tt class="PARAMETER"><i>GL_LINEAR_MIPMAP_LINEAR</i></tt>, o OpenGL 
escolhe dois mipmaps que mais aproximam o tamanho do pixel a ser texturizado 
calcula a média dos quatro elementos de textura mais próximos do centro do 
pixel. O valor da textura para o pixel será a média desses dois valores. O 
parâmetro <tt class="PARAMETER"><i>GL_LINEAR</i></tt>, por sua vez não utiliza 
mipmaps: associa ao pixel a ser texturizado a média dos quatro elementos de 
textura mais próximos do centro do pixel.</p></div></div>
<div class="NAVFOOTER">
<hr width="100%" align="left">

<table width="100%" border="0" cellpadding="0" cellspacing="0">
  <tbody>
  <tr>
    <td valign="top" width="33%" align="left"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/transformacoes-exercicios.html">Prev</a></td>
    <td valign="top" width="34%" align="middle"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/index2006.html">Home</a></td>
    <td valign="top" width="33%" align="right"><a href="http://www.ceset.unicamp.br/%7Emagic/opengl/modelagem-outros.html">Next</a></td></tr>
  <tr>
    <td valign="top" width="33%" align="left">Transformações - exercícios</td>
    <td valign="top" width="34%" align="middle">&nbsp;</td>
    <td valign="top" width="33%" align="right">Outros programas relacionados</td></tr></tbody></table></div></body></html>